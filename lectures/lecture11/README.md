# Лекция 11. Коллекции. Некоторые аспекты

## Паттерн "Итератор"

Представим себе класс `Cart`, который хранит набор положенных в корзину товаров и класс `Order`, в задачу которого входит формирование заказа из помещенных в корзину товаров. Для упрощения примера, представим себе, что "корзина" реализована обычным массивом и можем содержать не более 5 элементов.

Давайте внимательно посмотрим на метод `makeOrder()`. Он получает на вход объект `Cart`, после чего он должен взять каждое наименование и цену товара и, допустим, добавить его в базу данных. Как это сделать?

Самый очевидный способ реализовать перебор товаров - создадим геттер для поля `items` в классе `Cart`, после чего в методе `makeOrder()` с помощью цикла обойдем все элементы массива.

```java
class Cart {
    private Item[] items;
    private int index;

    public Cart() {
        items = new Item[5];
        index = 0;
    }

    public boolean addItem(Item item) {
        // Добавление товара в корзину
        return true;
    }
}

...

Cart cart = new Cart();
cart.addItem(new Item("Часы", 2000));
cart.addItem(new Item("Чашка", 250));
cart.addItem(new Item("Блокнот", 80));

Order order = new Order();
order.makeOrder(cart);
```

Обратим внимание на метод `makeOrder()`. Ему передается ссылка на объект класса `Cart`, после чего он должен взять каждый объект класса `Item`, который находится в корзине и, допустим, добавить его в базу данных. Как реализовать это поведение?

Самый очевидный способ реализовать перебор товаров в корзине - создать геттер для поля `items` в классе `Cart`, после чего в методе `makeOrder()` с помощью цикла обойти все элементы массива.

```java
class Cart {
    private Item[] items;

    ... 

    public Item[] getItems() {
        return items;
    }
}

class Order {
    public void makeOrder(Cart cart) {
        for (int i = 0; i < cart.getItems().length; i++) {
            Item item = cart.getItems()[i];

            // Работа с товаром
        }
    }
}
```

Подобное решение является некорректным с точки зрения дизайна ОО-приложений по следующим причинам:

- нарушается принцип инкапсуляции, так как вы показываете внутреннюю структуру объекта. Сторонний класс может случайно или специально испортить структуру и тогда объектом нельзя будет пользоваться;
- класс `Order` теперь зависит от внутренней структуры класса `Cart` и, если мы каким-то образом изменим внутреннюю структуру класса (например, мы захотим вместо массива использовать какую-то коллекцию), или с помощью наследования модифицируем существующий класс – нам необходимо будет переписывать метод `makeOrder()`;
- мы устанавливаем сильную связь между логически разными классами, которые выполняют разные функции в приложении. Это нарушает принцип модульности.

Необходимо решить следующую задачу: необходимо обойти все элементы «корзины» и добавить их в базу данных, но мы не должны показать внутреннюю структуру объекта типа `Cart`, класс `Order` должен работать успешно при любых изменениях внутри класса `Cart`.

Для решения этой задачи можно воспользоваться часто применяемым и очень простым паттерном проектирования, который называется **Итератор** (он относится к категории паттернов поведения).

Краткое описание паттерна можно сформулировать так: **итератор – это объект, который предоставляет интерфейс последовательного доступа к содержимому составных объектов, не раскрывая другим классам его внутренней структуры**.

Давайте напишем свою версию этого паттерна. Прежде всего, нам необходимо описать интерфейс «Итератор», который будет описывать методы итератора.

```java
interface Iterator<E> {
    
    // Возвращает следующий элемент
    E next();
    
    // Возвращает true, если еще есть
    // следующий элемент, который можно получить с
    // помощью метода next()
    boolean hasNext();
}
```

Так как наш итератор может работать с разными элементами внутри составных объектов, то сделаем его обобщенным. Метод `next()` при каждом вызове возвращает следующий элемент составного объекта. То есть, если мы последовательно будем вызывать метод `next()`, то он будет возвращать первый, второй, третий и т.д. элементы составного объекта.

Метод `hasNext()` возвращает нам сведения о том – есть ли еще элементы, которые мы не обошли с помощью метода `next()`. Если впереди еще есть элементы – метод вернет `true`, если элементы закончились – он вернет `false`.

Итак, мы описали интерфейс для итератора, теперь необходимо создать класс, который будет реализовывать интерфейс итератора. Для этого, необходимо создать так называемый внутренний класс.

```java
class Cart {
    private Item[] items;
    private int index;

    ...

    private class CartIterator implements Iterator<Item> {
        private int cursor = 0;

        @Override
        public Item next() {
            if (hasNext())
                return items[cursor++];
            else
                return null;
        }

        @Override
        public boolean hasNext() {
            return cursor < index;
        }
    }
}
```

В классе `Cart` создадим метод `getIterator()`, который будет создавать объект внутреннего класса `CartIterator` и возвращать его.

```java
class Cart {
    private Item[] items;
    private int index;

    private class CartIterator implements Iterator<Item> {
        private int cursor = 0;

        @Override
        public Item next() {
            if (hasNext())
                return items[cursor++];
            else
                return null;
        }

        @Override
        public boolean hasNext() {
            return cursor < index;
        }
    }
}
```

Теперь вернемся к классу `Order`. В методе `makeOrder()` получим объект итератора и проитерируем товары в корзине.

```java
class Order {
    public void makeOrder(Cart cart) {
        for (int i = 0; i < cart.getItems().length; i++) {
            
            Iterator<Item> iterator = cart.getIterator();
            while (iterator.hasNext()) {
                Item item = iterator.next();
                
                // Работа с товаром
            }
        }
    }
}
```

В результате получилась следующая картина:

- класс `Order` не имеет доступа к внутренней структуре объекта типа `Cart`;
- класс `Cart` может спокойно изменить свою структуру – достаточно лишь переписать методы внутреннего класса `CartIterator`, чтобы реализовать методы итератора с учетом изменений структуры класса `Cart`;
- класс `Order` будет продолжать нормальную работу, если внутренняя структура класса `Cart` изменится – главное, чтобы были корректно реализованы методы итератора;
- вы можете предусмотреть несколько реализаций итератора и метод `getIterator()` может возвращать ту или иную реализацию интерфейса (например, вы можете предусмотреть несколько итераторов для обхода бинарного дерева – каждый итератор будет реализовывать свой способ обхода).

В реальности нам нет нужды создавать свой интерфейс итератора – правильно будет воспользоваться стандартным интерфейсом `java.util.Iterator` и `java.lang.Iterable`. Это «стандартные» интерфейсы итератора, который все используют и в 99.9% случаях вы тоже должны его использовать.

Переделаем наш код для использования стандартных интерфейсов. Для начала перепишем внутренний класс `CartIterator`, чтобы он реализовывал интерфейс `java.util.Iterator`. Он мало чем отличается от нашего «самодельного» интерфейса Итератора. Минимально необходимо реализовать методы `next()` и `hasNext()`. Для полной реализации интерфейса необходимо дополнительно реализовать методы `remove()` и `forEachRemaining()`.

Далее следует указать, что наш класс `Cart` может предоставить итератор для последовательного доступа к элементам составного объекта. Для этого укажем, что наш класс реализует интерфейс `Iterable<Item>`. Для минимальной реализации интерфейса `Iterable` необходимо реализовать метод `Iterator<T> iterator()`, который возвращает объект класса, реализующего интерфейс `java.util.Iterator`.

```java
class Cart implements Iterable<Item> {
    private Item[] items;
    private int index;

    ...

    @Override
    public java.util.Iterator<Item> iterator() {
        return new CartIterator();
    }

    private class CartIterator implements Iterator<Item> {
        private int cursor = 0;

        @Override
        public Item next() {
            if (hasNext())
                return items[cursor++];
            else
                return null;
        }

        @Override
        public boolean hasNext() {
            return cursor < index;
        }
    }
}
```

Таким образом, мы указали, что наш класс `Cart` может вернуть объект итератора для последовательного доступа к элементам своей внутренней структуры. Реализация интерфейса `Iterable<T>` часто бывает полезна: некоторые методы в стандартных библиотеках Java принимают на входы объекты интерфейсного типа `Iterable<T>`, кроме того, вы теперь можете обойти элементы внутри `Cart` с помощью цикла конструкции for-each.

```java
class Order {
    public void makeOrder(Cart cart) {

        for (Item item : cart) {
            // Работа с товаром
        }
    }
}
```

### Итераторы в коллекциях

Поддержка итераторов – неотъемлемая часть работы с коллекциями. В интерфейсе `Collection` определен метод `iterator()`, который возвращает объект итератора. Таким образом, все коллекции, которые реализуют интерфейс `Collection`, имеют реализованный класс итератора.

Работа с итератором коллекции ничем не отличается от использования итератора в нашем примере. Необходимо:

1. Запросить у `Collection` итератор посредством метода `iterator()`. Полученный итератор готов вернуть начальный элемент последовательности;
2. Получить следующий элемент последовательности вызовом метода `next()`;
3. Проверить, есть ли еще объекты в последовательности (метод `hasNext()`);
4. Удалить из последовательности последний элемент, возвращаемый итератором, методом `remove()`.

### Интерфейсы `ListIterator` и `Spliterator`

Интерфейс `ListIterator` представляет собой более мощную разновидность `Iterator`, которая работает только с классами `List`. Хотя `Iterator` может перемещаться только вперед, итератор `ListIterator` является двусторонним. Он может выдать индексы следующего и предыдущего элементов относительно текущей позиции итератора в списке, а также заменить последний посещенный элемент методом `set()`. Метод `listIterator()` возвращает объект `ListIterator`, указывающий в начало `List`, а вызов `listIterator(n)` создает объект `ListIterator`, изначально установленный в позицию списка с индексом `n`. Подробнее про `ListIterator` смотрите [здесь](http://metanit.com/java/tutorial/5.10.php).

В версии Java 8 появился еще один тип итератора – `Spliterator`. Он позволяет разбивать коллекцию на части, что позволяет обрабатывать коллекции параллельно в несколько потоков. На данном этапе концепция сплитератора может показаться вам непонятной, поэтому оставим его за скобами. Для любопытных – можете почитать [здесь](https://habrahabr.ru/post/256905/).

## Фабрики коллекций

В Java 9 появилось несколько новых удобных способов создания небольших коллекций. Представим себе, что нам необходимо создать небольшую коллекцию из трех объектов. Один из способов может быть такой:

```java
List<String> friends = new ArrayList<>();
friends.add("John");
friends.add("Sam");
friends.add("Peter");
```

Мы можем сократить количество кода с помощью фабричного метода `Arrays.asList()`:

```java
List<String> friends = Arrays.asList("John", "Sam", "Peter");
```

При этом создается список фиксированного размера, значения в котором можно менять, нельзя лишь добавлять и удалять элементы. Попытка добавления элементов приводит к генерации исключения `UnsupportedOperationException`, обновление же списка с помощью метода `set` вполне допустимо:

```java
List<String> friends = Arrays.asList("John", "Sam", "Peter");
friends.set(0, "Mark"); // Допустимо
friends.add("Serge"); // Ошибка! Генерация исключения
```

Для создания множеств можно воспользоваться конструктором класса `HashSet`, который принимает в качестве аргумента список:

```java
Set<String> friends = new HashSet<>(Arrays.asList("Raphael", "Olivia", "Thibaut"));
```

Или можно воспользоваться Stream API:

```java
Set<String> friends = Stream.of("Raphael", "Olivia", "Thibaut")
        .collect(Collectors.toSet());    }
```

В результате мы получим изменяемый `Set`.

### Фабрики списков

Для создания списка достаточно вызвать фабричный метод `List.of()`

```java
List<String> friends = List.of("John", "Sam", "Peter");
```

Полученный список - неизменяемый. Попытка добавить, удалить или изменить элемент с помощью `set()` приводит к генерации исключения `UnsupportedOperationException`. Пустые элементы (`null`) также не разрешены. Поля объектов внутри коллекций можно менять, нельзя менять саму коллекцию.

Если вы не планируете изменять содержимое списка, то лучше воспользоваться именно фабричными методами.

### Фабрики множеств


