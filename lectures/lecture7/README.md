# Лекція 7. Анонімні класи, інтерфейси, методи. Лямбда-вирази.

## Анонімний об'єкт

При створенні об'єктів за допомогою оператора `new` повертається посилання на новостворений об'єкт. Однак нас ніхто не зобов'язує це посилання привласнювати як значення посилальної змінної. У таких випадках створюється **анонімний об'єкт**. Іншими словами, об'єкт є, а змінна, яка б містила посилання на цей об'єкт, відсутня.

З практичної точки зору це може виглядати марним, однак, анонімні об'єкти потрібні досить часто - зазвичай в тих ситуаціях, коли об'єкт класу використовується один раз. Розглянемо приклад:

```java
class PrintManager {

    // Различные поля и методы
    public void printFile(File file) {
        // Распечатка файла на принтере   
    }
}
```

В даному випадку, нам потрібен об'єкт класу `PrintManager` тільки для одного виду діяльності - для роздруківки файлу. Тобто, ми створюємо об'єкт, викликаємо метод, після чого об'єкт нам більше не потрібен.

У таких випадках зручно використовувати анонімні об'єкти.

```java
File file = new File("file.txt");

// Обычное создание объекта и вызов его метода
PrintManager manager = new PrintManager();
manager.printFile(file);

// Использование анонимного объекта
new PrintManager().printFile(file);

// Использование двух анонимных объектов
new PrintManager().printFile(new File("file.txt"));
```

У першому випадку використовується звичайний порядок роботи з об'єктами - створюємо об'єкт класу `PrintManager`, посилання на об'єкт записується в посилальну змінну` manager`.
У другому випадку ми створюємо анонімний об'єкт. Інструкція

```java
new PrintManager().printFile(file);
```

виконується наступним чином. Спочатку створюється новий об'єкт класу `PrintManager`, оператор `new` повертає посилання на створений об'єкт. Після чого, ми викликаємо метод `printFile()` з аргументом `file`.

У третьому випадку, ми як аргумент методу `printFile()` передаємо анонімний об'єкт класу `File`. В цьому випадку, посилання на об'єкт класу `File` буде зберігати параметр методу `printFile()` всередині тіла методу.

## Анонімні класи

Механізм анонімних класів дозволяє оголосити клас і відразу створити його екземпляр. Це дозволяє зробити код коротким і виразним. Анонімні класи зручно використовувати, якщо клас потрібен один раз.

Основна особливість - анонімний клас не має імені. **Анонімний клас може бути підкласом існуючого класу або реалізацією інтерфейсу.**

Особливості анонімного класу:

- немає явного конструктора;
- до анонімного класу неможливо звернутися ззовні виразу, шо його оголосило;
- анонімні класи не можуть бути статичними;
- анонімний клас завжди кінцевий ( `final`);
- кожне оголошення анонімного класу унікально.

У прикладі нижче оголошені два анонімні класи, які є підкласами `PrintManager`. Обидва анонімних класи є різними унікальними класами.

```java
PrintManager manager1 = new PrintManager() {
    @Override
    public void printFile(File file) {
        super.printFile(file);
    }
};

PrintManager manager2 = new PrintManager() {
    @Override
    public void printFile(File file) {
        super.printFile(file);
    }
};
```

## Анонімні методи (лямбда-вирази)

> ⚠️ Через особливості реалізації лямбда-виразів в Java, подальша інформація з приводу лямбда-виразів справедлива тільки для мови Java.

**Лямбда-вираз** - це анонімний метод, тобто метод без назви. Такий метод виконується не самостійно, а служить для реалізації функціонального інтерфейсу. Таким чином, лямбда-вираз призводить до деякої формі анонімного класу.

**Функціональний інтерфейс** - інтерфейс, який містить один і тільки один абстрактний метод. Як правило, такий метод визначає передбачуване призначення інтерфейсу. Отже, функціональний інтерфейс представляє єдину дію. До функціональних інтерфейсів можна віднести, наприклад, інтерфейс `ActionListener` або `Comparator`.

Для оголошення такого інтерфейсу використовується анотація `@FunctionalInterface`. Інтерфейс, позначений цією анотацією, передбачає його використання у вигляді лямбда-виразу, яке пропонує більш лаконічний синтаксис при створенні функцій-об'єктів.

Лямбда-вирази дозволяють оголосити метод і відразу ж використовувати його. Це корисно у випадках одноразового виклику методу, так як скорочує час на оголошення і написання методу без необхідності створювати окремий клас. Лямбда-вираз в Java має наступний синтаксис:

```
(аргументы) -> (тело выражения)
```

Лямбда-вираз вносить новий елемент в синтаксис і оператор в мову Java. Цей новий оператор називається лямбда-оператором, або операцією "стрілка" `->`. Він розділяє лямбда-вираз на дві частини. У лівій частині вказуються будь-які параметри, що вимагаються в лямбда-виразі (якщо параметри не потрібні, то вони вказуються порожнім списком). А в правій частині знаходиться тіло лямбда-виразу, де вказуються дії, що виконуються лямбда-виразом. Операція `->` буквально означає "ставати" або "переходити".

В Java визначені два різновиди тіл лямбда-виразів. Один з них складається з єдиного виразу (одиночний вираз), а інший - з блоку коду (блочне вираз).

### Одиночний лямбда-вираз

Для початку розглянемо найпростіший лямбда-вираз. Це буде вираз, який не приймає ніяких параметрів, а повертає константу. Також оголосимо метод, що аналогічний лямбда-виразу.

```java
() -> 99

public double foo() {
    return 99;
}
```

Наведемо ще один приклад вже більше корисного виразу

```java
() -> Math.random() * 100

public double foo() {
    return Math.random() * 100;
}
```

Із коду зрузуміло, що лямбда-вираз повертає псевдовипадкове значення, помножене на 100.
Два перших приклади не приймають ніяких параметрів. Якщо ж вам необхідно передати параметри, вони вказуються списком в лівій частині лямбда-оператора.

```java
(a, b) -> a * b

public double foo(int a, int b) {
    return a * b;
}
```

Тип параметрів можна вказувати явно, але найчастіше в цьому немає необхідності, тому що тип параметрів виводиться.

Лямбда-вираз не виконується самостійно, а скоріше утворює реалізацію абстрактного методу, визначеного в функціональному інтерфейсі. Таким чином, лямбда-вираз може бути зазначений лише в тому контексті, в якому визначені його цільової тип. Один з таких контекстів створюється в тому випадку, коли лямбда-вираз присвоюється посиланням на функціональний інтерфейс. До числа інших контекстів цільового типу відносяться ініціалізація змінних, оператор `return` і аргументи методів.

```java
@FunctionalInterface
interface MyInterface {
    double foo(int a, int b);
}
// 1. Лямбда-вираз присвоюється посилальній змінній

// Змінна a1 вказує на об'єкт анонімного класу
// який реалізує інтерфейс MyInterface
MyInterface a1 = new MyInterface() {
    @Override
    public double foo(int a, int b) {
        return 0;
    }
};

// Змінна a2 вказує на лямбда-вираз
MyInterface a2 = (a, b) -> a * b;
System.out.println(a2.foo(2, 5)); // Виведе 10
```

Розглянемо ще один приклад

```java
public static void main(String[] args) {
    MyInterface b1 = foo();
    MyInterface b2 = foo2();
}

// 2. Метод повертає лямбда-вираз
public static MyInterface foo() {
    return (a, b) -> Math.pow(a, b);
}

// Це можна було зробити за допомогою об'єкта анонімного класу
// Але, оцініть, наскільки лямбда-вираз коротше і наочніше
public static MyInterface foo2() {
    return new MyInterface() {
        @Override
        public double foo(int a, int b) {
            return Math.pow(a, b);
        }
    };
}
```

Розглянемо ще один приклад

```java
public static void main(String[] args) {

    // 3. Передача лямбда-виразу як аргумент методу
    func((a, b) -> 2 * b + 3 * a);

    // Реалізація за допомогою об'єкта анонімного класу
    func(new MyInterface() {
        @Override
        public double foo(int a, int b) {
            return 2 * b + 3 * a;
        }
    });
}

public static void func(MyInterface i) {
    i.foo(10, 20);
}
```

### **Блокові лямбда-вирази**

Попередні приклади містили в тілі лише один вираз. Ми вже знаємо, що такі лямбда-вирази називаються одиночними.

Але вам нічого не заважає створювати блокові лямбда-вирази, які в тілі містять блок виразів. В такому блоці можна створювати цикли, розгалуження - все як у звичайному блоці виразів.

При створенні блочного виразу необхідно явно вказати оператор `return`.

```java
public static void main(String[] args) {
    
    // Передаємо в метод блочний лямбда-вираз
    foo((array) -> {
        for (int i = 0; i < array.length; i++) {
            System.out.println("№ " + i + ": value: " + array[i]);
        }
        return true;
    });

    // Реалізація за допомогою об'єкта анонімного класу
    foo(new MyFunctionalInterface() {
        @Override
        public boolean printIntArray(int[] array) {
            for (int i = 0; i < array.length; i++) {
                System.out.println("№ " + i + ": value: " + array[i]);
            }
            return true;
        }
    });
}

public static void foo(MyFunctionalInterface i) {
    i.printIntArray(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9});
}
```

## Взаємодія анонімних класів і лямбда-виразів з локальними змінними

Через особливості внутрішнього устрою анонімних класів і лямбда-виразів, робота з локальними змінними, що оголошені поза анонімного класу і лямбда-виразу, має певні обмеження.
Припустимо, оголошений наступний функціональний інтерфейс

```java
@FunctionalInterface
interface Printer {
    void print();
}
```
Розглянемо наступний код

```java
String name = "Hello!";

new Printer() {
    @Override
    public void print() {
        System.out.println(name);
    }
}.print();
```

Зверніть увагу, що ми зчитуємо значення локальної змінної `name`, яка оголошена поза лямбда-виразу.
Даний код буде успішно скомпільовано і додаток виведе в консоль

```
Hello!
```

Але якщо ми спробуємо змінити значення змінної `name`, програма видасть помилку компіляції.

```java
String name = "Hello!";

// Ми модифікуємо значення локальної змінної
name = "HEY!";

new Printer() {
    @Override
    public void print() {
        System.out.println(name);
    }
}.print();
```

Буде виведена наступна помилка

```
java: local variables referenced from an inner class must be final or effectively final
```

Таку ж помилку ми отримаємо в разі використання лямбда-виразу

```java
String name = "Hello!";

// Ми модифікуємо значення локальної змінної
name = "HEY!";

Printer p = () -> System.out.println(name);
p.print();
```

> ❗ **Причина помилки полягає в наступному - якщо локальна змінна використовується в анонімному класі або в лямбда-виразі і оголошена поза цього виразу, її значення
> не повинно змінюватися**

Отже, хорошим рішенням було б оголосити змінну `name` як `final`

```java
final String name = "Hello!";

Printer p = () -> System.out.println(name);
p.print();
```

Фраза `effectively final` означає, що хоча змінна може не бути оголошена як` final`, але фактично її значення не повинно змінюватися.
Усередині лямбда-виразу або анонімного класу значення локальної змінної теж не повинно змінюватися. Наступний код теж викличе помилку.

```java
final String name = "Hello!";

Printer p = () -> {
    name = "HEY!";
    System.out.println(name);
};
p.print();
```
