# Лекция 10. Коллекции. Множества и отображения

## Интерфейс `Set`

В интерфейсе Set определяется множество. Он расширяет интерфейс Collection и определяет поведение коллекций, не допускающих дублирования элементов. Таким образом, метод add() возвращает false при попытке ввести в множество дублирующий элемент. В этом интерфейсе не определяется никаких дополнительных методов.

```java
Set<String> set;
```

Интерфейс `Set` не добавляет никакой функциональности по сравнению с интерфейсом `Collection`, поэтому в `Set` нет дополнительный функциональности. Вместо этого Set представляет собой разновидность `Collection`.

### Класс `HashSet`

Хеш-таблица хранит информацию, используя так называемый механизм хеширования, в котором содержимое ключа используется для определения уникального значения, называемого хеш-кодом. Хеш-код затем применяется в качестве индекса, с которым ассоциируются данные, доступные по этому ключу. Преобразование ключа в хеш-код выполняется автоматически - вы никогда не узнаете самого хеш-кода. Также ваш код не может напрямую индексировать хеш-таблицу.

:warning:**Выгода от хеширования состоит в том, что оно обеспечивает константное время выполнения методов `add()`, `contains()`, `remove()` и `size()`, даже для больших объемов данных.**:warning:

Если вы хотите использовать `HashSet` для хранения объектов собственных пользовательских классов, то вы **ДОЛЖНЫ** переопределить методы `hashCode()` и `equals()`, иначе два логически-одинаковых объекта будут считаться разными, так как при добавлении элемента в коллекцию будет вызываться метод `hashCode()` класса `Object` (который вернет разный хеш-код для двух логически одинаковых объектов).

Важно отметить, что класс `HashSet` не гарантирует упорядоченности элементов, поскольку процесс хеширования сам по себе обычно не порождает сортированных наборов. Если вам нужны сортированные наборы, то лучшим выбором может быть класс `TreeSet`.

### Класс TreeSet

`TreeSet` - коллекция, которая хранит свои элементы в виде упорядоченного дерева. `TreeSet` использует сбалансированное красно-черное дерево для хранения элементов.

:warning:**Для операций `add()`, `remove()`, `contains()` потребуется гарантированное время `log(n)`.**:warning:

## Интерфейс Map

Интерфейс `Map` описывает коллекцию, состоящую из пар "ключ-значение". У каждого ключа только одно значение, что соответствует математическому понятию однозначной функции или отображения. Такую коллекцию часто называют **словарем** (dictionary) или **ассоциативным массивом** (associative array). Несмотря на то, что интерфейс `Map` входит в список коллекций Java, он не расширяет интерфейс `Collection`.

```java
Map<K, V> map;
```

Здесь в качестве `K` указывается тип ключа, а в качестве `V` - тип значения. Рассмотрим основные методы, объявленные в интерфейсе `Map`.

Обращение с отображениями опирается на две основные операции, выполняемые методами `get()` и `put()`. Чтобы ввести значение в отображение, следует вызвать `put()`, указав ключ и значение, а для того чтобы получить значение из отображения - вызвать метод `get()`, передав ему ключ в качестве аргумента. По этому ключу будет возвращено связанное с ним значение.

### Интерфейс Map.Entry

Этот интерфейс позволяет обращаться с отдельными записями в отображении. Напомним, что метод `entrySet()`, объявляемый в интерфейсе `Map`, возвращает множество типа `Set`, содержащее записи из отображения. Каждый элемент этого множества представляет собой объект типа `Map.Entry`. Интерфейс `Map.Entry` является обобщенным и объявляется следующим образом:

где `K` обозначает тип ключей, а `V` - тип хранимых в отображении значений.

### Класс HashMap

Этот класс расширяет класс `AbstractMap` и реализует интерфейс `Map`. В нем используется хеш-таблица для хранения отображений, и благодаря этому обеспечивается постоянное время выполнения методов `get()` и `put()`, даже в случае отображения с большим количеством элементов. Класс `HashMap` является обобщенным и объявляется приведенным ниже образом, где `K` обозначает тип ключей, а `V` - тип хранимых в отображении значений.

### Класс TreeMap

Класс `TreeMap` расширяет класс `AbstractMap` и реализует интерфейс `NavigableMap`. В нем создается отображение, размещаемое в древовидной структуре. В классе `TreeMap` предоставляются эффективные средства для хранения пар "ключ-значение" в отсортированном порядке и обеспечивается их быстрое извлечение. Следует заметить, что в отличие от `HashMap`, древовидное отображение гарантирует, что его элементы будут отсортированы по порядку возрастания ключей. Класс `TreeMap` является обобщенным и объявляется следующим образом

где `K` обозначает тип ключей, а `V` - тип хранимых в отображении значений.

## Вспомогательный класс `Collections`

В фреймворке коллекций определяется ряд алгоритмов, которые можно применять к коллекциям и отображениям. Эти алгоритмы определены в виде статических методов класса `Collections`. По сути, класс `Collections` предоставляет огромный набор методов для различных операций с коллекциями.

:warning:**Полный список методов класса `Collections` можно найти [по этой ссылке]()**:warning:

Приведем список наиболее полезных методов класса `Collections`

:warning:**В рамках данного курсе мы не будем подробно рассматривать методы этого класса, важно запомнить одно правило - если вы хотите произвести какие-то манипуляции с коллекцией - сначала попробуйте найти нужный функционал в классе `Collections`. Скорее всего, он там будет присутствовать в виде готового метода.**:warning:

## Вспомогательный класс Arrays

Также, в пакете `java.util` присутствует класс `Arrays`. Класс `Arrays` предоставляет различные удобные методы для работы с массивами. Эти методы помогает восполнить функциональный пробел между коллекциями и массивами. Например, метод `asList()` возвращает список, исходя из указанного массива, а метод `binarySearch()` использует алгоритм двоичного поиска для обнаружения заданного значения.

:warning:**Полный список методов класса `Arrays` можно найти [по этой ссылке]()**:warning:

Приведем список наиболее полезных методов класса `Arrays`

:warning:**Применительно к классу `Arrays` действует то же правило - если вы хотите произвести какие-то манипуляции с массивом - сначала попробуйте найти нужный функционал в классе `Arrays`. Скорее всего, он там будет присутствовать в виде готового метода.**:warning:

## Сравнительная таблица временной сложности основных операций с коллекциями

Ниже приведена таблица, которая позволит вам облегчить процесс выбора нужной коллекции

<p align="center">
  <img src="img/image.png" />
</p>
