# Лекция 7. Анонимные классы, интерфейсы, методы. Лямбда-выражения.

## Анонимный объект

При создании объектов с помощью оператора new возвращается ссылка на вновь созданный объект. Однако нас никто не обязывает эту ссылку присваивать в качестве значения ссылочной переменной. В таких случаях создается **анонимный объект**. Другими словами, объект есть, а переменной, которая бы содержала ссылку на этот объект, нет.

С практической точки зрения это может выглядеть бесполезным, однако, анонимные объекты требуются довольно часто - обычно в тех ситуациях, когда объект класса используется один раз. Рассмотрим пример:

```java
class PrintManager {

    // Различные поля и методы
    public void printFile(File file) {
        // Распечатка файла на принтере   
    }
}
```

В данном случае, нам нужен объект класса `PrintManager` только для одного действия - для распечатки файла. То есть, мы создаем объект, вызываем метод, после чего объект нам больше не нужен.

В таких случаях удобно использовать анонимные объекты.

```java
File file = new File("file.txt");

// Обычное создание объекта и вызов его метода
PrintManager manager = new PrintManager();
manager.printFile(file);

// Использование анонимного объекта
new PrintManager().printFile(file);

// Использование двух анонимных объектов
new PrintManager().printFile(new File("file.txt"));
```
В первом случае используется обычный порядок работы с объектами - создаем объект класса `PrintManager`, ссылка на объект записывается в ссылочную переменную `manager`.
Во втором случае мы создаем анонимный объект. Инструкция

```java
new PrintManager().printFile(file);
```

выполняется следующим образом. Сначала создается новый объект класса `PrintManager`, оператор new возвращает ссылку на созданный объект. После чего, мы вызываем метод `printFile()` с аргументом `file`.

В третьем случае, мы в качестве аргумента метода `printFile()` передаем анонимный объект класса `File`. В этом случае, ссылку на объект класса File будет хранить параметр метода `printFile()` внутри тела метода.

## Анонимные классы

Механизм анонимных классов позволяет объявить класс и сразу создать его экземпляр. Это позволяет сделать код кратким и выразительным. Анонимные классы удобно использовать, если класс нужен единожды.

Основная особенность - анонимный класс не имеет имени. **Анонимный класс может быть подклассом существующего класса или реализацией интерфейса.**

Особенности анонимного класса:

- нет явного конструктора;
- к анонимному классу невозможно обратиться извне объявляющего его выражения;
- анонимные классы не могут быть статическими;
- анонимный класс всегда конечен (`final`);
- каждое объявление анонимного класса уникально.

В примере ниже объявлены два анонимный класса, которые являются подклассами `PrintManager`. Оба анонимных класса являются разными уникальными классами.
```java
PrintManager manager1 = new PrintManager() {
    @Override
    public void printFile(File file) {
        super.printFile(file);
    }
};

PrintManager manager2 = new PrintManager() {
    @Override
    public void printFile(File file) {
        super.printFile(file);
    }
};
```

## Анонимные методы (лямбда-выражения)

>⚠️ Из-за особенностей реализации лямбда-выражений в Java, дальнейшая информация по поводу лямбда-выражений справедлива только для языка Java.

**Лямбда-выражение** - это анонимный метод, то есть метод без названия. Такой метод выполняется не самостоятельно, а служит для реализации функционального интерфейса. Таким образом, лямбда-выражение приводит к некоторой форме анонимного класса.

**Функциональный интерфейс** - интерфейс, который содержит один и только один абстрактный метод. Как правило, такой метод определяет предполагаемое назначение интерфейса. Следовательно, функциональный интерфейс представляет единственное действие. К функциональным интерфейсам можно отнести, например, интерфейс `ActionListener` или `Comparator`.

Для объявления такого интерфейса используется аннотация `@FunctionalInterface`. Интерфейс, помеченный этой аннотацией, предполагает его использование в виде лямбда-выражения, которое предлагает более лаконичный синтаксис при создании функций-объектов.

Лямбда-выражения позволяют объявить метод и сразу же использовать его. Это полезно в случаях однократного вызова метода, так как сокращает время на объявление и написание метода без необходимости создавать отдельный класс. Лямбда-выражение в Java имеет следующий синтаксис:

```
(аргументы) -> (тело выражения)
```
Лямбда-выражение вносит новый элемент в синтаксис и оператор в язык Java. Этот новый оператор называется лямбда-оператором, или операцией "стрелка" `->`. Он разделяет лямбда-выражение на две части. В левой части указываются любые параметры, требующиеся в лямбда-выражении (если параметры не требуются, то они указываются пустым списком). А в правой части находится тело лямбда-выражения, где указываются действия, выполняемые лямбда-выражением. Операция `->` буквально означает "становиться" или "переходить".

В Java определены две разновидности тел лямбда-выражений. Одна из них состоит из единственного выражения (одиночное выражение), а другая - из блока кода (блочное выражение).

### Одиночное лямбда-выражение

Для начала рассмотрим самое простое лямбда-выражение. Это будет выражение, которое не принимает никаких параметров, а возвращает константу. Также объявим метод, который аналогичен лямбда-выражению.

```java
() -> 99

public double foo() {
    return 99;
}
```

Приведем еще один пример уже более полезного выражения

```java
() -> Math.random() * 100

public double foo() {
    return Math.random() * 100;
}
```

Как вам понятно, лямбда-выражение возвращает псевдослучайное значение, умноженное на 100.
Два первых примера не принимают никаких параметров. Если же вам необходимо передать параметры, они указываются списком в левой части лямбда-оператора.

```java
(a, b) -> a * b

public double foo(int a, int b) {
    return a * b;
}
```

Тип параметров можно указывать явно, но зачастую в этом нет необходимости, потому что тип параметров выводится.

Лямбда-выражение не выполняется самостоятельно, а скорее образует реализацию абстрактного метода, определенного в функциональном интерфейсе. Таким образом, лямбда-выражение может быть указано только в том контексте, в котором определен его целевой тип. Один из таких контекстов создается в том случае, когда лямбда-выражение присваивается ссылке на функциональный интерфейс. К числу других контекстов целевого типа относятся инициализация переменных, оператор `return` и аргументы методов.

```java
@FunctionalInterface
interface MyInterface {
    double foo(int a, int b);
}
// 1. Лямбда-выражение присваивается ссылочной переменной

// Переменная a1 указывает на объект анонимного класса
// который реализует интерфейс MyInterface
MyInterface a1 = new MyInterface() {
    @Override
    public double foo(int a, int b) {
        return 0;
    }
};

// Переменная a2 указывает на лямбда-выражение
MyInterface a2 = (a, b) -> a * b;
System.out.println(a2.foo(2, 5)); // Выведет 10
```

Рассмотрим еще один пример

```java
public static void main(String[] args) {
    MyInterface b1 = foo();
    MyInterface b2 = foo2();
}

// 2. Метод возвращает лямбда-выражение
public static MyInterface foo() {
    return (a, b) -> Math.pow(a, b);
}

// Это можно было сделать с помощью объекта анонимного класса
// Но оцените, насколько лямбда-выражение короче и нагляднее
public static MyInterface foo2() {
    return new MyInterface() {
        @Override
        public double foo(int a, int b) {
            return Math.pow(a, b);
        }
    };
}
```

Рассмотрим еще один пример

```java
public static void main(String[] args) {

    // 3. Передача лямбда-выражения как аргумент метода
    func((a, b) -> 2 * b + 3 * a);

    // Реализация с помощью объекта анонимного класса
    func(new MyInterface() {
        @Override
        public double foo(int a, int b) {
            return 2 * b + 3 * a;
        }
    });
}

public static void func(MyInterface i) {
    i.foo(10, 20);
}
```

### **Блочные лямбда-выражения**

Предыдущие примеры содержали в теле выражения лишь одно выражение. Мы уже знаем, что такие лямбда-выражения называются одиночными.

Но ничего вам не мешает создавать блочные лямбда-выражения, которые в теле содержат блок выражений. В таком блоке можно создавать циклы, ветвления - все как в обычном блоке выражений.

При создании блочного выражения необходимо явно указать оператор `return`.

```java
public static void main(String[] args) {
    
    // Передаем в метод блочное лямбда-выражение
    foo((array) -> {
        for (int i = 0; i < array.length; i++) {
            System.out.println("№ " + i + ": value: " + array[i]);
        }
        return true;
    });

    // Реализация с помощью объекта анонимного класса
    foo(new MyFunctionalInterface() {
        @Override
        public boolean printIntArray(int[] array) {
            for (int i = 0; i < array.length; i++) {
                System.out.println("№ " + i + ": value: " + array[i]);
            }
            return true;
        }
    });
}

public static void foo(MyFunctionalInterface i) {
    i.printIntArray(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9});
}
```

## Функциональный дескриптор

Мы уже сказали выше, что функциональный интерфейс - это интерфейс, который определяет только один абстрактный метод. Сигнатура абстрактного метода функционального интерфейса - это сигнатура лямбда-выражения. Этот абстрактный метод называется **дескриптором функции** или **функциональным дескриптором**.

Например, для следующего функционального интерфейса

```java
@FunctionalInterface
interface Func {
    String foo(int a, int b);
}
```
Функциональный дескриптор выглядит так

```
(int, int) -> String
```
Потому что лямбда, построенная из данного функционального интерфейса, будет представлять собой два значения типа `int` в качестве входа и объект типа `String` на выходе.

Приведем еще несколько примеров функциональных дескрипторов

```java
// Дескриптор: (double, int) -> void
@FunctionalInterface
interface Func2 {
    void foo(double a, int b);
}

// Дескриптор: () -> Socket
@FunctionalInterface
interface Func3 {
    Socket foo();
}

// Дескриптор: () -> void
@FunctionalInterface
interface Func4 {
    void foo();
}
```

## Взаимодействие анонимных классов и лямбда-выражений с локальными переменными

Из-за особенности внутреннего устройства анонимных классов и лямбда-выражений, работа с локальными переменными, объявленными вне анонимных классов и лямбда-выражений, имеет определенные ограничения.

Допустим, объявлен следующий функциональный интерфейс

```java
@FunctionalInterface
interface Printer {
    void print();
}
```

Рассмотрим следующий код

```java
String name = "Hello!";

new Printer() {
    @Override
    public void print() {
        System.out.println(name);
    }
}.print();
```

Обратите внимание, что мы считываем значение локальной переменной `name`, объявленной вне лямбда-выражения. 

Данный код будет успешно скомпилирован и приложение выведет в консоль
```
Hello!
```

Но если мы попытаемся изменить значение переменной `name`, программа выдаст ошибку компиляции.

```java
String name = "Hello!";

// Мы меняем значение локальной переменной
name = "PRIVET";

new Printer() {
    @Override
    public void print() {
        System.out.println(name);
    }
}.print();
```
Будет выведена следующая ошибка

```
java: local variables referenced from an inner class must be final or effectively final
```

Такую же ошибку мы получим в случае использования лямбда-выражения

```java
String name = "Hello!";

// Мы меняем значение локальной переменной
name = "PRIVET";

Printer p = () -> System.out.println(name);
p.print();
```

> ❗ **Причина ошибки заключается в следующем - если локальная переменная используется в анонимном классе или в лямбда-выражении и объявлена вне этого выражения, ее значение
> не должно меняться**

Следовательно, хорошим решением было бы объявить переменную `name` как `final`

```java
final String name = "Hello!";

Printer p = () -> System.out.println(name);
p.print();
```

Фраза `effectively final` означает, что хотя переменная может не быть объявлена как `final`, но фактически ее значение не должно меняться.

Внутри лямбда-выражения или анонимного класса значение локальной переменной тоже не должно меняться. Следующий код тоже вызовет ошибку.

```java
final String name = "Hello!";

Printer p = () -> {
    name = "PRIVET!";
    System.out.println(name);
};
p.print();
```

## Параметризация поведения

Одна из широко известных проблем в сфере разработки программного обеспечения заключается в том, что, независимо от ваших действий, требования пользователя к ПО все равно изменятся. Как справиться со всеми этими постоянно меняющимися требованиями? В идеале желательно минимизировать выполняемую работу. Кроме того, хотелось бы простоты реализации и сопровождения новой функциональности в долгосрочной перспективе.

**Параметризация поведения (behavior parametrization)** - паттерн разработки программного обеспечения, нацеленный на решение проблемы частых изменений требований. В нашем случае это достигается с помощью передачи блока кода в виде аргумента методу, который выполнит этот блок позднее. В результате поведение метода параметризуется этим блоком кода. Например, при обработке коллекции могут понадобиться написать метод, который:
- выполняет какое-либо действие над каждым элементом списка;
- выполняет какое-либо другое действие по окончании обработки списка;
- выполняет какое-нибудь еще действие в случае ошибки.

Вот это и есть **параметризация поведения**.

Писать код, способный справляться с меняющимися требованиями, - непростая задача. Рассмотрим пример, который мы будем постепенно совершенствовать, попутно демонстрируя рекомендуемые практики для повышения гибкости кода.

Допустим, у нас есть класс `Apple`

```java
class Apple {

    private String color;
    private int weight;

    // Геттеры, сеттеры и конструкторы
}
```

Представим себе, что нам необходимо написать код, который осуществляет фильтрацию зеленых яблок из списка. Первое решение, которое приходит на ум, может быть таким





