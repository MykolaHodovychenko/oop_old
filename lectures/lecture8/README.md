# Лекція 8. Узагальнені типи. Автоупаковка та автоупаковка. Узагальнений інтерфейс, метод, конструктор

Узагальнення з'явилися у версії Java 5.0 і були одним із найважливіших нововведень до виходу версії Java 8. Узагальнення орієнтуються на абстракцію і дозволяють створювати класи та методи, які працюють однаково для різних типів об'єктів. Поняття "загальний" походить від ідеї, що потрібна можливість писати загальні алгоритми, які можуть широко використовуватися заново в багатьох типах об'єктів, а не адаптувати наш код, щоб він підходив під кожну умову. Узагальнення Java не так додають нові можливості мови, скільки роблять код Java, який можна використовувати повторно, легшим для написання та читання.

Узагальнення переносять повторне використання на новий рівень, роблячи **тип** об'єктів, із якими ми працюємо, явним параметром коду. Тому на узагальнення також посилаються як на **параметризовані типи**. У випадку загального класу розробник вказує тип як параметр (аргумент), коли він використовує загальний тип. Клас параметризується наданим типом, якого адаптується сам код.

Застосування узагальнень дозволило створювати класи, інтерфейси та методи, що обробляють різноманітні типи даних безпечно. Багато алгоритмів логічно ідентичні, незалежно від того, до яких типів вони застосовуються. Наприклад, механізм, що підтримує стеки, є загальним для стеків, що зберігають елементи типу `Student`, `String`, `Object` тощо. Завдяки узагальненням можна визначити алгоритм один раз незалежно від конкретного типу даних, а потім застосовувати його до різних типів даних без будь-яких додаткових зусиль.

> В інших мовах програмування до узагальнення іноді посилаються як до шаблонів, що більше є поняттям реалізації. Шаблони схожі на проміжні класи, які чекають на свої параметри типу, і тоді вони можуть використовуватися.

<p align="center">
  <img src="img/cup.png" />
</p>

Узагальнений код буде автоматично працювати з типом даних, переданим йому як параметр. Багато алгоритмів виконуються однаково, незалежно від того, до якого типу вони будуть застосовуватися. Наприклад, сортування не залежить від типу даних, будь то `String`, `Student` або будь-який інший користувальницький клас, об'єкти якого можна порівняти між собою. Використовуючи узагальнення можна реалізувати алгоритм один раз, а потім застосовувати його без додаткових зусиль до будь-якого типу даних.

Розглянемо невеликий приклад. Розглянемо клас `Box`, який може містити один об'єкт.

```java
class Box {
    
    private String item;

    Public Box(String item) {
        put(item);
    }

    public void put(String item) {
        this.item = item;
    }

    public String get() {
        return item;
    }
}
```

В даному випадку наша коробка зберігає об'єкти класу `String`. Припустимо, що у нашій програмі необхідна коробка, яка б зберігала не тільки об'єкти класу `String`, але й об'єкт будь-якого іншого класу, як стандартного з бібліотек Java, так і нашого створеного? Як ми можемо це реалізувати за допомогою вже відомих механізмів ООП?
Ми можемо використати механізм поліморфізму. Наприклад, ми можемо використовувати клас `Object`, який, як відомо, є суперкласом для всіх класів Java.

```java
class Box {

    private Object item;

    Public Box(Object item) {
        put(item);
    }

    public void put(Object item) {
        this.item = item;
    }

    public Object get() {
        return item;
    }
}
```

Другий варіант - оголосити інтерфейс `BoxItem` і використовувати його як тип посилальної змінної. Тоді в коробку можна буде покласти об'єкт класу, який реалізує цей інтерфейс.

```java
interface BoxItem {}

class Box {

    private BoxItem item;

    Public Box(BoxItem item) {
        put(item);
    }

    public void put(BoxItem item) {
        this.item = item;
    }

    public BoxItem get() {
        return item;
    }
}
```

Метод став трохи загальнішим і може використовуватися у більшій кількості місць. Однак, величезний недолік такого підходу - необхідність низхідного перетворення видобутого з коробки об'єкта. Якщо ж ми не знаємо заздалегідь, об'єкт якого класу буде поміщений у коробку, то й спадне перетворення реалізувати буде досить складно.

```java
Box box = new Box(new Item());
Object obj = box.get();

if (obj instanceof Item) {
    Item item = (Item) obj;
}
```

Який вихід може бути з цієї ситуації? У Java та інших ОО-мовах програмування існує **механізм узагальнених типів**. Цей механізм дозволяє нам створювати класи, методи та інтерфейси, які автоматично працюватимуть з типами даних, які будуть передані пізніше, при створенні об'єкта цього класу.

## Узагальнені класи

Реалізуємо клас `Box` за допомогою механізму узагальнених типів

```java
class Box<T> {

    private T item;

    Public Box(T item) {
        put(item);
    }

    public void put(T item) {
        this.item = item;
    }

    public T get() {
        return item;
    }
}
```

Такий клас називається узагальненим класом. Під терміном узагальнення слід розуміти "застосовність до великої групи класів". Ідентифікатор `T` між кутовими дужками `<>` називається **типізованою змінною**. Він вказує, що клас `Box` вимагає тип Java як аргумент, щоб зробити його повним. Ім'я `T` є довільним, але існують угоди (вони описані наприкінці лекції). У цьому випадку типізована змінна `T` є типом елементів, який ми хочемо зберігати в коробці.

Створимо об'єкт класу `Box`

```java
Box<Item> box = new Box<>(new Item());
```

Після створення об'єкта узагальненого класу, замість `T` буде підставлений тип `Item`

```java
Box<Item> box = new Box<>(new Item());

box.put(new Item());
Item i = box.get();
```

Тобто, нам немає необхідності займатися низхідним перетворенням та приведенням типів - об'єкт класу `Box` працюватиме з класом `Item`.

#### ⚠️Механізм узагальнення працює тільки з посилальними типами!⚠️

Коли оголошується екземпляр узагальненого типу, аргумент, що передається параметру типу, повинен бути посилальним типом. Використовувати примітивні типи, наприклад, `int` або `char`, не можна. Наступний код спричинить помилку компіляції

```java
Box<int> box = new Box<>(20); // помилка компіляції
```

Для подолання цієї проблеми в Java передбачений механізм **автоупаковки (autoboxing)** та **авторозпаковки (unboxing)**, який дозволяє використовувати класи-оболонки типів даних (їх ще називають **"обгортки"**, **wrapper**).

## Механізм автоупаковки та автозапаковки

У п'ятій версії Java були додані два дуже корисні механізми - **автоупаковка** і **автораспаковка**, які суттєво спрощують і прискорюють створення коду, в якому доводиться перетворювати прості типи даних на об'єкти і навпаки.

Як знаємо, Java передбачено 8 примітивних типів даних. Примітивні типи даних мають переваги в порівнянні з об'єктами, але механізм узагальнених типів і багато структур даних у Java припускають роботу з об'єктами і тому в них не можна зберігати дані простих типів.

Для вирішення цієї проблеми в Java передбачені класи-обгортки (wrappers). Класи-обгортки реалізуються в класах 'Double', 'Float', 'Long', 'Integer', 'Short', 'Byte', 'Character' і 'Boolean'. Усі обгортки числових типів даних є похідними від абстрактного класу `Number`.

Процес перетворення значення примітивного типу на об'єкт відповідного класу-обгортки називається **упаковкою (boxing)**.
Процес вилучення значення примітивного типу з об'єкта-обгортки називається **розпаковуванням (unboxing)**.

**Автоупаковка** - процес автоматичного пакування (інкапсуляції) простого типу даних в об'єктну обгортку без необхідності явного створення об'єкта.

```java
Integer i = 5; // Автоупаковка
foo(5); // Автоупаковка під час передачі функції аргументу
Double result = bar(); // Автоупаковка при отриманні результату

void foo (Integer i) {
    ...
}

double bar() {
    return 0.0;
}
```

**Автоупаковка** - це зворотний процес автоматичного розпакування (вилучення) значення, упакованого в об'єктну оболонку.

```java
Integer i = 5;
int a1 = i; // авторозпакування

int a2 = New Integer(10); // Старий варіант
int a3 = Integer.valueOf(10); // новий варіант

Integer a4 = 10;
foo(a4); // Автоупаковка при передачі функції аргументу

double result = bar(); // Автоупаковка при отриманні результату

static void foo(int i) {
    ...
}

static Double bar() {
    return 0.0;
}
```

## Передача кількох параметризованих типів

Кількість типів, які можна передати до узагальненого класу, не обмежена. Щоб передати кілька типів, їх потрібно перерахувати через кому. Синтаксис оголошення посилання та створення такого об'єкта аналогічний до створення об'єкта з одним параметром.

```java
DualBox<String, Integer> box = new DualBox<>("Вася", 2);

class DualBox<T, V> {
    private T firstItem;
    private V secondItem;

    public DualBox(T firstItem, V secondItem) {
        this.firstItem = firstItem;
        this.secondItem = secondItem;
    }
}
```

## Обмеження типів

Дуже часто при використанні узагальнень необхідно обмежити типи, які можуть бути передані класу. Наприклад, при написанні узагальненого класу, який виконує операції з числами, необхідно вказати, що як тип можна передати тип `Number`.
Для цього необхідно після параметру типу написати ключове слово `extends` та вказати ім'я класу (у цьому випадку будуть доступні об'єкти цього типу або типів-спадкоємців) або інтерфейс (об'єкти типів, які реалізують інтерфейс). Зверніть увагу, що для інтерфейсу також використовується ключове слово `extends`.

```java
class NumericValue<T extends Number> {
    private T value;

    public NumericValue(T value) {
        this.value = value;
    }
}

NumericValue<Double> num1 = New NumericValue<>(100.0);
NumericValue<Integer> num2 = New NumericValue<>(100);
NumericValue<Long> num3 = New NumericValue<>(100L);
```

Якщо клас приймає кілька типів, ми можемо вказати один тип як обмежувач другого. Таким чином, можна гарантувати, що обидва класи сумісні один з одним.

```java
class Pair<T, V extends T> {}
```

При вказанні обмежень, ви можете визначити, що параметр типу повинен успадковувати клас і реалізовувати чи кілька інтерфейсів. Для цього необхідно використовувати оператор `&`.

```java
class MyClass<T extends SomeClass & SomeInterface1 & SomeInterface2> {}
```

## Узагальнений інтерфейс

Узагальнений інтерфейс оголошується як і узагальнений клас

```java
interface MyInterface<T> {
    void foo(T value);
}
```

Якщо клас реалізує узагальнений інтерфейс, він також має бути узагальненим. Не узагальненим він може бути тільки в тому випадку, якщо ви явно вказуєте тип при оголошенні класу.

```java
interface MyInterface<T> {
    void foo(T value);
}

// Помилка, клас має бути узагальненим
class MyClass1 implements MyInterface<T> {
    @Override
    public void foo(T value) {}
}

// Правильне оголошення. Клас, що реалізує
// узагальнений інтерфейс, має бути узагальненим
class MyClass2<T> implements MyInterface<T> {
    @Override
    public void foo(T value) {}
}

// Ми явно вказали параметр типу інтерфейсу
// і клас може бути не узагальненим
class MyClass3 implements MyInterface<Double> {
    @Override
    public void foo(Double value) {}
}
```

В інтерфейсі можна вказати обмеження за допомогою ключового слова `extends`. Клас, який реалізує узагальнений інтерфейс з обмеженням, також повинен дотримуватися цих обмежень. При оголошенні класу обмеження слід прописати після назви класу, але після ключового слова `implements` його дублювати не треба.

```java
interface Iface<T extends Number> {}

// Видасть помилку
class MyClass4<T> implements Iface<T>{}

// Все вірно
class MyClass5<T extends Number> implements Iface<T> {}

// Видасть помилку
class MyClass6<T extends Number> implements Iface<T extends Number>{}
```

## Передача об'єкта узагальненого класу в методи

Для того, щоб мати можливість використовувати узагальнений клас як аргумент методу, необхідно використовувати так званий "шаблон аргументу" (wildcard).

Припустимо, потрібно реалізувати метод, який порівнює два об'єкти класу `NumericValue` та повертає `true`, якщо обидва об'єкти рівні.
Необхідно повідомити компілятор, що вхідним аргументом є об'єкт узагальненого класу. Написати `NumericValue<T>` не вийде, оскільки це оголошення класу, а записати якесь конкретне значення ми можемо, оскільки хочемо подати об'єкт узагальненого типу з будь-яким допустимим типом даних. Для такого випадку використовується спеціальний символ `?`, який є шаблоном аргументу.

```java
boolean isEquals(NumericValue<?> obj1, NumericValue<?> obj2) {
    double d1 = Math.abs(obj1.value.doubleValue());
    double d2 = Math.abs(obj2.value.doubleValue());

    return d1 == d2;
}

class NumericValue<T extends Number> {
    T-value;

    public NumericValue(T value) {
        this.value = value;
    }
}
```

Така сигнатура методу означає, що метод `isEquals()` приймає на вхід аргументи узагальненого типу `NumericValue`, де параметр типу може бути будь-яким допустимим для типу `NumericValue`.

### Обмеження знизу при використанні шаблону аргументу

Крім "обмеження зверху", ми можемо встановлювати "обмеження знизу", тобто встановити як коректний тип цей тип і суперкласи вище за ланцюжком успадкування. Це реалізується за допомогою ключового слова `super`.

```java
void foo(GenericClass<? super C> obj1, GenericClass<? super B> obj2) {
    // Типи obj1 можуть бути C, B, A, Object
    // Типи obj2 можуть бути B, A, Object
}

class GenericClass<T> {}

class A {}
class B extends A {}
class C extends B {}
class D extends C {}
```

## Узагальнені методи

Методи в узагальнених класах можуть використовувати параметр типу свого класу, отже, автоматично стають узагальненими щодо параметра класу. Проте можна оголосити узагальнений метод, який сам собою використовує параметр типу. Більше того, такий метод може бути оголошений у звичайному, а не узагальненому класі.
Наприклад, реалізуємо способи, який порівнюватиме два масиву узагальнених типів. Спочатку оголосимо два класи

```java
class Student {
    private String name;
    private int avgMark;

    public Student(String name, int avgMark) {
        this.name = name;
        this.avgMark = avgMark;
    }
}

class PostGradStudent extends Student {
    private String phDTopic;

    Public PostGradStudent(String name, int avgMark, String phDTopic) {
        super(name, avgMark);
        this.phDTopic = phDTopic;
    }
}
```

Далі оголосимо метод `compareArrays()`

```java
public <T extends Comparable<T>, V extends T> boolean compareArrays(T[] arg0, V[] arg1) {
    if (arg0.length! = arg1.length)
        return false;
    
    for (int i = 0; i < arg0.length; i++) {
        if (!arg0[i].equals(arg1[i]))
            return false;
    }

    return true;
}
```

Вираз `T` extends `Comparable<T>` означає, що тип `T`має реалізовувати узагальнений інтерфейс `Comparable<T>`, тобто щоб ми могли порівняти об'єкт типу `T` з іншим об'єктом типу `T`. Вираз `V extends T` означає, що тип `V` повинен бути або типом `T` або похідним від `T` типом.

Створимо два масиви і спробуємо викликати метод `compareArrays()`.

```java
Student[] students1 = new Student[10];
PostGradStudent[] students2 = новий PostGradStudent[10];

compareArrays(students1, students2);
```

Такий код викликає помилку компіляції, тому що тип `Student` не реалізує інтерфейс `Comparable<Student>`.
  
```
java: метод compareArrays in class com.company.Main cannot be applied to given types;
  required: T[],V[]
  found: com.company.Student[],com.company.PostGradStudent[]
  reason: inference variable T має incompatible bounds
    lower bounds: java.lang.Comparable<T>
    lower bounds: com.company.Student
````

Виправимо цю помилку

```java
class Student implements Comparable<Student> {
    private String name;
    private int avgMark;

    public Student(String name, int avgMark) {
        this.name = name;
        this.avgMark = avgMark;
    }

    @Override
    public int compareTo(Student o) {
        return this.avgMark - o.avgMark;
    }
}
```

Якщо ми перепишемо клас `PostGradStudent` так, щоб він не є спадкоємцем типу `Student`, то при виконанні коду отримаємо таку помилку

```
java: метод compareArrays in class com.company.Main cannot be applied to given types;
  required: T[],V[]
  found: com.company.Student[],com.company.PostGradStudent[]
  reason: inference variable V має incompatible bounds
    lower bounds: java.lang.Comparable<T>,T
    lower bounds: com.company.PostGradStudent
```

## Узагальнений конструктор

Оскільки конструктор є методом, ми також можемо оголошувати узагальнені конструктори. Узагальнений конструктор можна оголосити навіть тоді, коли сам клас не є узагальненим.

```java
class Accumulator {

    public <T extends Number> Accumulator(T number1, T number2) {
        // ...
    }
}

Accumulator accumulator = новий Accumulator(5, 10);
Accumulator accumulator2 = новий Accumulator(5.5d, 10L);
Accumulator accumulator3 = новий Accumulator(5.5d, "four"); // Викличе помилку
```

## Угода за правилами назви параметрів типу

Відповідно до загальноприйнятих правил та конвенції коду, параметри типів записуються у вигляді одного символу алфавіту у верхньому регістрі. Рекомендується використовувати такі символи алфавіту:

- `E` (означає Element, що часто використовується в колекціях);
- `K` (означає Key);
- `N` (означає Number);
- `T` (означає Type);
- `V` (означає Value);
- `S`, `U` - зазвичай другі, треті, четверті параметри типу.

## Список додаткової літератури на тему узагальнень у Java

- [Німеєр, Леук "Програмування на Java. Вичерпне керівництво"] (https://cutt.ly/3RUXJV7), розділ 8
- [Брюс Еккель - Філософія Java] (https://rutracker.org/forum/viewtopic.php?t=4941725), розділ 15
- [Прийшов, побачив, узагальнив: поринаємо в Java Generics](https://habr.com/ru/company/sberbank/blog/416413/)
