# Принцип инверсии управления и внедрение зависимостей. Использование Spring Core для внедрения зависимостей. Spring IoC-контейнер. Виды связывания (wiring). Разрешение зависимостей. Классы JavaBeans.

Любое мало-мальски серьезное приложение состоит из нескольких классов, которые взаимодействуют друг с другом, чтобы реализовывать бизнес-логику. Обычно, каждый объект отвечает за получение ссылок на другие объекты, с которыми он взаимодействует (такие другие объекты называются **зависимостями**, **dependencies**). Такой подход может привести к созданию тесно связанного кода, который тяжело тестировать.

Рассмотрим небольшой участок кода, который состоит из класса `User` и класса `Sender`.

```java
public class User {

    public void sendMessage(String message, String target) {
        Sender sender = new Sender();
        sender.send(message, target);
    }
}

public class Sender {

    public void send(String message, String target) {
        System.out.println("Tweet: " + message + " to " + target);
    }
}
```

В результате мы получим тесно связанный код – класс `User` теперь напрямую зависит от класса `Sender`. Таким образом, если мы создадим класс `EmailSender`, который будет отсылать сообщения по электронной почте, то чтобы использовать объект класса `EmailSender`, нам придется изменять код класса `User`. К тому же, тестирование метода `sendMessage()` будет затруднительным.

Безусловно, мы не можем избежать связывания вообще, т.к. объектно-ориентированное программирование подразумевает взаимодействие множества объектов различных классов, программа из одного класса не имеет смысла. С другой стороны, нам необходимо избегать **тесного связывания** (**tight coupling**) классов, так как такой код тяжело повторно использовать, тестировать и тяжело понять, как это всё вместе работает.

В противовес тесному связыванию кода существует принцип слабо связного (**loose coupling**) кода. Слабая связность означает, что изменения, вносимые в один класс, повлекут за собой небольшие изменения в другие классы, что упростит тестирование, рефакторинг, повторное использование кода. Приложение с использованием принципа слабо связного кода легче модифицируется и поддерживается.

## Инверсия управления

Одним из приемов для написания слабо связного кода является принцип **инверсии управления** (**Inversion of Control**, IoC). Он заключается в том, что жизненным циклом (созданием, вызовом методов и уничтожением) ваших объектов управляете не вы сами, а некий сторонний код. Отсюда и термин «инверсия» – не я управляю кодом, а сторонний код управляет моими классами. Он решает, когда создавать объекты моих классов, когда вызывать их методы и когда уничтожать объекты. На принципе инверсии управления базируется работа всех фреймворков.

> Подробно читайте про инверсию контроля [здесь](http://martinfowler.com/bliki/InversionOfControl.html) или [здесь](https://habr.com/post/116232/).

Отличие библиотеки от фреймворка состоит в том, что библиотека – это по существу набор функций, организованных в классы, которые вы можете вызывать по мере надобности. Каждый вызов выполняет некоторую работу и возвращает управление обратно пользователю.

С другой стороны, фреймворк воплощает в себе некоторый абстрактный дизайн приложения со своим поведением. Для того, чтобы использовать его, вы должны добавить свой код в различные места фреймворка, либо через наследование, либо подключив свой собственный класс. Код фреймворка впоследствии будет вызывать ваш код.

## Внедрение зависимости

