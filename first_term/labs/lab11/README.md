# Лабораторная работа 11. "Паттерн "Итератор". Потоки данных в Java"

## Цели лабораторной работы

- изучить принцип работы паттерна "Итератор"
- изучить способы обработки данных с помощью потоков данных

## Описание заданий

### Задание 1. Паттерн "Итератор"

1. Напишите обобщенную версию класса `NumberStack`, который реализует стек для объектов типа `Number`.

Класс `NumberStack` реализует функционал стека **для объектов классов `Number` и производных от класса `Number`**.

Для внешнего пользователя класса, поведение класса выглядит следующим образом:

- пользователь может создать новый стек с конструктором без параметров;
- пользователю доступна команда `pop()` для извлечения элемента из стека. Метод `pop()` возвращает извлеченный элемент. При попытке извлечь из пустого стека, метод возвращает `0` или выбрасывает исключение (реализуйте выброс исключения, если вы знаете, как это делать и что такое исключение);
- пользователю доступна команда `push()`, которая добавляет элемент в стек;
- пользователю доступна команда `peek()` для просмотра элемента на вершине стека без его исключения;
- пользователь может получить значение количества элементов в стеке с помощью метода `size()`;
- пользователь может проверить, пустой ли стек с помощью метода `isEmpty()`;
- пользователь может очистить стек полностью с помощью метода `clear()`.

2. Реализуйте итератор для класса `NumberStack` (при каждом вызове метода `next()` происходит `pop()` из стека с возвращением извлеченного объекта)

### Задание 2. Простые задания по теме Stream API

#### Задание 2.1

Реализуйте метод `doubling()`, который принимает на вход список целых чисел и возвращает новый список, где каждое число умножено на 2.

Пример:

```java
doubling([1, 2, 3]) -> [2, 4, 6]
doubling([6, 8, 6, 8, -1]) -> 12, 16, 12, 16, -2]
doubling([]) -> []
```

#### Задание 2.2

Реализуйте метод `copies3()`, который принимает на вход список строк и возвращает новый список, где каждая строка является конкатенацией исходной строки три раза.

Пример:

```java
copies3(["a", "bb", "ccc"]) → ["aaa", "bbbbbb", "ccccccccc"]
copies3(["24", "a", ""]) → ["242424", "aaa", ""]
copies3(["hello", "there"]) → ["hellohellohello", "theretherethere"]
```

#### Задание 2.3

Реализуйте метод `noX()`, который принимает на вход список строк и возвращает новый список, из которого убраны строки, в которых есть символ `x`

Пример:

```java
noX(["ax", "bb", "cx"]) → ["bb"]
noX(["xxax", "c"]) → ["c"]
noX(["x"]) → []
```

#### Задание 2.4

Реализуйте метод `no9()`, который принимает на вход список целых чисел и возвращает новый список, из которого убраны числа, которые заканчиваются на `9`

Пример:

```java
no9([1, 2, 19]) → [1, 2]
no9([9, 19, 29, 3]) → [3]
no9([1, 2, 3]) → [1, 2, 3]
```

#### Задание 2.5

Реализуйте метод `refinedStrings()`, который принимает на вход список строк и возвращает новый список, который не содержит одинаковых строк и строки отсортированы в порядке убывания длины строки.

Пример:

```java
refinedStrings(["aa", "c", "aa", "bbb"]) → ["bbb", "aa", "c"]
refinedStrings(["aa"]) → ["aa"]
refinedStrings([]) → []
```

#### Задание 2.6

Реализуйте метод `flatten()`, который принимает на вход список строк вида "Имя Фамилия" и возвращает новый список строк, в котором содержатся отдельно имена и фамилии из строк исходного списка. Разбиение строки происходит по пробелу между именем и фамилией.

*Подсказка: используйте `flatmap()` в котором разбивайте строку на массив строк и берите stream этого массива. Можете сначала в потоке преобразовать каждую строку в массив, а потом применить `flatmap()`*

Пример:

```java
flatten(["John Wick", "John Snow", "AlexMurphy"]) → ["John", "Wick", "John", "Snow", "AlexMurphy"]
flatten(["Peter Parker"]) → ["Peter", "Parker"]
flatten(["NeroWolfe"]) → ["NeroWolfe"]
flatten([]) → []
```
