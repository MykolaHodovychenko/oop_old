### Завдання на контрольну роботу.

#### Тема: Колекції в Java.

### Завдання 1

Реалізуйте метод `removeShorterStrings()`, який приймає `List<String>` та видаляє з кожної пари рядків рядок з меншою довжиною.

Наприклад, для списку

`{"four", "score", "and", "seven", "years", "ago"}`

будуть такі пари рядків:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод повинен знайти рядок з меншою довжиною із кожної пари рядків та видалити його. Таким чином, метод повинен перетворити вхідний список на такий:

`{"score", "seven", "years"}`

Якщо рядки в парі будуть однакової довжини, метод повинен видалити перший рядок з пари.

Якщо список містить непарну кількість елементів, метод повинен залишити останній елемент у списку недоторканим.

**Метод повинен виконувати роботу в одному списку і не використовувати додаткові структури даних для зберігання проміжних результатів**

### Завдання 2

Реалізуйте метод `stutter()`, який приймає `List<String>` та дублює кожен рядок у списку.

Наприклад, якщо метод приймає на вхід список:

`{"how", "are", "you?"}`

тоді список слід змінити наступним чином:

`{"how", "how", "are", "are", "you?", "you?"}`

**Метод повинен виконувати роботу в одному списку і не використовувати додаткові структури даних для зберігання проміжних результатів**

### Завдання 3

Реалізуйте метод `switchPairs()`, який приймає `List<String>` ть попарно змінює елементи місцями.

Наприклад, для списку:

`{"four", "score", "and", "seven", "years", "ago"}`

список пар буде:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод повинен змінити елементи в кожній парі рядків. У результаті, метод повинен перетворити список таким чином:

`{"score", "four", "seven", "and", "ago", "years"}`

Якщо список містить непарну кількість елементів, метод повинен залишити останній елемент у списку недоторканим.

**Метод повинен виконувати роботу в одному списку і не використовувати додаткові структури даних для зберігання проміжних результатів**

### Завдання 4

Реалізуйте метод `removeDuplicates()`, який приймає `List<String>` та видаляє із списку дублікати (**рядки в списку будуть відсортовані**).

Припустимо, є вхідний список:

`{"be", "be", "is", "not", "or", "question", "that", "the", "to", "to"}`

Метод повинен перетворити список таким чином:

`{"be", "is", "not", "or", "question", "that", "the", "to"}`

Оскільки список буде відсортований, дублікати будуть згруповані разом.

**Метод повинен виконувати роботу в одному списку і не використовувати додаткові структури даних для зберігання проміжних результатів**

### Завдання 5

Реалізуйте метод `markLength4()`, який приймає `List<String>` та додає рядок `****` перед кожним рядком із 4 символів.

Припустимо, є вхідний список:

`{"this", "is", "lots", "of", "fun", "for", "every", "Java", "programmer"}`

Метод повинен перетворити список таким чином:

`{"****", "this", "is", "****", "lots", "of", "fun", "for", "every", "****", "Java", "programmer"}`

Зверніть увагу, що оригінальні рядки з 4 символів не замінюються і не видаляються, а залишаються у списку. Рядок `****` додається перед рядком із 4 символів і не замінює його.

**Метод повинен виконувати роботу в одному списку і не використовувати додаткові структури даних для зберігання проміжних результатів**

### Завдання 6

Реалізуйте метод `isPalindrome()`, який приймає у якості вхідного параметра `Queue<Integer>` та повертає `true`, якщо числа в черзі представляють паліндром (і `false` у іншому випадку). Послідовність чисел вважається паліндромом, якщо вона є однаковою у зворотному порядку. Наприклад, припустимо, що черга з ім'ям `q` зберігає такі значення:

front `[3, 8, 17, 9, 17, 8, 3]` back

Метод `isPalindrome(q)` повинен повернути `true`, тому що ця послідовність ідентична у зворотньому напрямку. Якщо б черга мала такі значення:

front `[3, 8, 17, 9, 4, 17, 8, 3]` back

то метод `isPalindrome()` повернув би `false`, тому що така послідовність не є ідентичною в зворотньому порядку (9 та 4 в середині не співпадають). Пусту чергу необхідно розглядати як паліндром.

Ви на можете робити ніяких припущень щодо того, скільки елементів знаходиться в черзі. Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стека для вирішення цієї задачі.

**Додаткове завдання** Реалізуйте метод таким чином, щоб в ітозі вхідна черга залишилась в такому же вигляді, в якому вона була на початку роботи метода.

### Завдання 7

Реалізуйте метод `reorder()`, який приймає `Queue<Integer>` у якості вхідного аргументу. Вхідна черга відсортована **за зростанням абсолютного значення** (без урахування знаку). Приклад такої черги:

front `[1, 2, -2, 4, -5, 8, -8, 12, -15, 23]` back

Метод `reorder()` повинен **змінити вхідну чергу** (метод не повинен створювати нові колекції та повинен повертати `void`), щоб вона була відсортована за зростанням з урахуванням знаку.

Наприклад, для черги вище, метод `reorder()` повинен переставити значення таким чином, щоб вона мала вигляд:

front `[-15, -8, -5, -2, 1, 2, 4, 8, 12, 23]` back

Ви можете використати один екземпляр `ArrayDeque<Integer>` у якості допоміжного стека для вирішення цієї задачі.

### Завдання 8

Реалізуйте метод `rearrange()`, який приймає на вхід `Queue<Integer>` та змінює порядок значень таким чином, щоб всі парні значення з'явилися перед непарними значеннями

меняет порядок значений таким образом, чтобы все четные значения появлялись перед нечетными значениями, сохраняя порядок следования четных и нечетных чисел между собой. Например, предположим, что очередь с именем `q` хранит такую последовательность значений:

Напишите метод `rearrange()`, который принимает на вход `Queue<Integer>` в качестве параметра и меняет порядок значений таким образом, чтобы все четные значения появлялись перед нечетными значениями, сохраняя порядок следования четных и нечетных чисел между собой. Например, предположим, что очередь с именем `q` хранит такую последовательность значений:

front `[3, 5, 4, 17, 6, 83, 1, 84, 16, 37]` back

Вызов метод `rearrange(q)` должен поменять содержимое входящей очереди следующим образом:

front `[4, 6, 84, 16, 3, 5, 17, 83, 1, 37]` back

Обратите внимание, что все четные числа появляются в начале очереди, за которыми следуют нечетные, и что порядок четных чисел такой же, как в исходной очереди и порядок нечетных чисел такой же, как в исходной очереди. Вы можете использовать один экземпляр `ArrayDeque<Integer>` в качестве вспомогательного стека для решения этой задачи.

### Задание 9

Реализуйте метод `maxLength()`, который принимает `Set` строк и возвращает длину самой длинной строки в множестве. Если будет передан пустой `Set`, максимальная длина должна быть `0`.

Например, если подать множество `("one", "two", "three")`, то метод должен вернуть `5` - длину строки `"three"`.

### Задание 10

Реализуйте метод `removeEvenLength()`, который принимает `Set` строк и удаляет из `Set` все строки четной длины.

Например, если передать методу множество

`("foo", "buzz", "bar", "fork", "bort", "spoon", "!", "dude")`

то метод должен вернуть множество

`("foo", "bar", "spoon", "!")`

### Задание 11

Реализуйте метод `numInCommon()`, который принимает на вход два `List<Integer>` в качестве входных аргументов и возвращает количество уникальных целых чисел, которые встречаются в обоих списках. Используйте один или несколько `Set` для решения этой задачи.

Например, если первый входящий список содержит такие значения

`[3, 7, 3, -1, 2, 3, 7, 2, 15, 15]`

а второй список содержит такие значения

`[-5, 15, 2, -1, 7, 15, 36]`

ваш метод должен вернуть `4` (потому что элементы `-1, 2, 7, 15` встречаются в обоих списках).

### Задание 12

Реализуйте метод `isUnique()`, который принимает `Map<String, String>` в качестве параметра и возвращает `false`, если хотя бы два ключа отображаются на одно и то же значение и `true` в противном случае.

Например, при следующих параметрах метод вернет `true`:

`{Marty=Stepp, Stuart=Reges, Jessica=Miller, Amanda=Camp, Hal=Perkins}`

Вызов метода при следующих параметрах вернет `false`, потому что в коллекции повторяются значения `Perkins` и `Reges`:

`{Kendrick=Perkins, Stuart=Reges, Jessica=Miller, Bruce=Reges, Hal=Perkins}`

Пустой `Map` считается уникальным, поэтому метод должен возвращать `true`.

### Задание 13

Реализуйте метод `intersect()`, который принимает на вход два экземпляра `Map<String, Integer>` и возвращает новый `Map`, который является пересечением первых двух.

Пересечением двух `Map` является `Map`, который включает набор пар ключ-значение, который встречается в обоих `Map`.

Например, метод принимает следующие `Map`:

`{Janet=87, Logan=62, Whitaker=46, Alyssa=100, Stefanie=80, Jeff=88, Kim=52, Sylvia=95}`

`{Logan=62, Kim=52, Whitaker=52, Jeff=88, Stefanie=80, Brian=60, Lisa=83, Sylvia=87}`

Метод вернет следующий результирующий `Map`:

`{Logan=62, Stefanie=80, Jeff=88, Kim=52}`

### Задание 14

Реализуйте метод `reverse()`, который принимает `Map<Integer, String>` и возвращает новый `Map<String, Integer>` в котором ключи и значения поменяны местами: в паре "ключ-значение", значение переходит на место ключа, а ключ - на место значения.

Если возникнет ситуация, когда в оригинальном `Map` есть пары с одинаковыми значениями `(k1, v)` и `(k2, v)`, то в новом `Map` вы можете включить любую из пар: пару `(v, k1)` или `(v, k2)`.
Например, если есть оригинальный `Map`

`{42=Marty, 81=Sue, 17=Ed, 31=Dave, 56=Ed, 3=Marty, 29=Ed}`

Ваш метод должен вернуть такой `Map` (порядок не имеет значения):

`{Marty=3, Sue=81, Ed=29, Dave=31}`

### Задание 15

Реализуйте метод `rarest()`, который принимает `Map<String, Integer>` и возвращает значение, которое наиболее редко встречается в `Map`.

Если есть несколько значений, которые встречаются с одинаковой редкостью, метод должен вернуть меньшее значение (значения в `Map` являются целыми числами).

К примеру, если метод принимает на вход такой `Map`:

`{Alyssa=22, Char=25, Dan=25, Jeff=20, Kasey=20, Kim=20, Mogran=25, Ryan=25, Stef=22}`

то он должен вернуть `22` (потому что оно встречается только 2 раза, значение `25` встречается 4 раза, значение `20` встречается 3 раза).

Если же метод принимает на вход такой `Map`:

`{Alyssa=22, Char=25, Dan=25, Jeff=20, Kasey=20, Kim=20, Mogran=25, Ryan=25, Stef=22, Kelly=22}`

то он должен вернуть `20` (значения `22` и `20` встречаются по 3 раза, но `20 < 22`).

### Задание 16

Реализуйте метод `maxOccurences()` принимает на вход `List<Integer>` в качестве входного аргумента и возвращает то, сколько раз встречается самое часто встречающееся целое число в списке.

Например, если на вход поступил такой список:

`[9, 7, 9, -1, 2, 9, 7, 2, 15, 15]`

то ваш метод должен вернуть `3`, потому что чаще всего в списке встречается число `9` и оно встречается в спике `3` раза.

Для решения задачи используйте `Map`. Если список пуст, то ваш метод должен вернуть `0`.
