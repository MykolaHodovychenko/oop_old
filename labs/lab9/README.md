# Лабораторная работа 9. "Коллекции в Java. Списки и очереди"

## Цели лабораторной работы:

- изучить предназначение коллекций и их сценарии использования
- изучить предназначение интерфейса `List` и особенности реализации этого интерфейса
- изучить предназначение интерфейса `Queue` и `Deque`, а также особенности реализации этого интерфейса

### Задание 1

Реализуйте метод `removeShorterStrings()`, который принимает `List<String>` и удаляет из каждой пары строк строку с меньшей длиной.

Например, для списка:

`{"four", "score", "and", "seven", "years", "ago"}`

список пар будет:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод должен найти строку с меньшей длиной из каждой пары строк и удалить ее. В итоге метод должен преобразовать строку следующим образом:

`{"score", "seven", "years"}`

Если строки в паре будут одинаковой длины, метод должен удалить первую строку из пары.

Если список будет содержать нечетное количество элементов, метод должен оставить последний элемент в списке нетронутым.

**Метод должен выполнять работу в этом же списке и не использовать дополнительные структуры данных для хранения промежуточных результатов.**

### Задание 2

Реализуйте метод `stutter()`, который принимает `List<String>` и дублирует каждую строку в списке.

Например, если метод принимает на вход список:

`{"how", "are", "you?"}`

то входная строка должна быть изменена следующим образом:

`{"how", "how", "are", "are", "you?", "you?"}`

**Метод должен выполнять работу в этом же списке и не использовать дополнительные структуры данных для хранения промежуточных результатов.**

### Задание 3

Реализуйте метод `switchPairs()`, который принимает `List<String>` и попарно меняет элементы местами.

Например, для списка:

`{"four", "score", "and", "seven", "years", "ago"}`

список пар будет:

- `{"four", "score"}`
- `{"and", "seven"}`
- `{"years", "ago"}`

Метод должен поменять элементы местами в каждой паре чисел. В итоге метод должен преобразовать строку следующим образом:

`{"score", "four", "seven", "and", "ago", "years"}`

Если список будет содержать нечетное количество элементов, метод должен оставить последний элемент в списке нетронутым.

**Метод должен выполнять работу в этом же списке и не использовать дополнительные структуры данных для хранения промежуточных результатов.**

### Задание 4

Реализуйте метод `removeDuplicates()`, который принимает `List<String>` и удаляет из списка дубликаты (строки в списке будут отсортированы).

Предположим, есть входящий список:

`{"be", "be", "is", "not", "or", "question", "that", "the", "to", "to"}`

Метод должен преобразовать строку следующим образом:

`{"be", "is", "not", "or", "question", "that", "the", "to"}`

Так как строка будет отсортирована, то дубликаты будут сгруппированы вместе.

**Метод должен выполнять работу в этом же списке и не использовать дополнительные структуры данных для хранения промежуточных результатов.**

### Задание 5

Реализуйте метод `markLength4()`, который принимает `List<String>` и добавляет строку `****` перед каждой строкой из 4 символов.

Предположим, есть входящий список:

`{"this", "is", "lots", "of", "fun", "for", "every", "Java", "programmer"}`

Метод должен преобразовать строку следующим образом:

`{"****", "this", "is", "****", "lots", "of", "fun", "for", "every", "****", "Java", "programmer"}`

Обратите внимание, что оригинальные строки из 4 символов не заменяются и не удаляются, а остаются в списке. Строка `****` добавляется перед такой строкой, а не заменяет ее.

**Метод должен выполнять работу в этом же списке и не использовать дополнительные структуры данных для хранения промежуточных результатов.**

### Задание 6

Напишите метод `isPalindrome()`, который принимает в качестве параметра `Queue<Integer>` и возвращает `true`, если числа в очереди представляют палиндром (и `false` в противном случае). Последовательность чисел считается палиндромом, если она одинакова в обратном порядке. Например, предположим, что очередь с именем `q` хранит такие значения:

front `[3, 8, 17, 9, 17, 8, 3]` back

Затем вызов `isPalindrome(q)` должен вернуть `true`, потому что эта последовательность такая же в обратном порядке. Если бы в очереди были сохранены такие значения:

front `[3, 8, 17, 9, 4, 17, 8, 3]` back

Вызов `isPalindrome()` вместо этого вернет `false`, потому что эта последовательность не совпадает в обратном порядке (9 и 4 в середине не совпадают). Пустую очередь следует рассматривать как палиндром. 

Вы не можете делать никаких предположений о том, сколько элементов находится в очереди. Вы можете использовать `Stack<Integer>` в качестве вспомогательного хранилища.

### Задание 7

Напишите метод `reorder()`, который принимает `Queue<Integer>` в качестве параметра. Входящая очередь отсортирована по возрастанию **абсолютного значения**. Пример такой входящей очереди:

front `[1, 2, -2, 4, -5, 8, -8, 12, -15, 23]` back

Метод `reorder()` должен **изменить входящую очередь** (метод не должен создавать новых очередей и должен возвращать `void`), чтобы она было отсортирована по возрастанию с учетом знака.

Метод `reorder()` должен переупорядочить значения приведенной выше очереди так, чтобы в очереди хранилась эта последовательность значений:

front `[-15, -8, -5, -2, 1, 2, 4, 8, 12, 23]` back

Вы можете использовать один экземпляр `Stack<Integer>` в качестве вспомогательного хранилища для решения этой задачи.

### Задание 8

Напишите метод `rearrange()`, который принимает на вход `Queue<Integer>` в качестве параметра и меняет порядок значений таким образом, чтобы все четные значения появлялись перед нечетными значениями, сохраняя порядок следования четных и нечетных чисел между собой. Например, предположим, что очередь с именем `q` хранит такую последовательность значений:

front `[3, 5, 4, 17, 6, 83, 1, 84, 16, 37]` back

Вызов метод `rearrange(q)` должен поменять содержимое входящей очереди следующим образом:

front `[4, 6, 84, 16, 3, 5, 17, 83, 1, 37]` back

Обратите внимание, что все четные числа появляются в начале очереди, за которыми следуют нечетные, и что порядок четных чисел такой же, как в исходной очереди и порядок нечетных чисел такой же, как в исходной очереди. Вы можете использовать один экземпляр `Stack<Integer>` в качестве вспомогательного хранилища.