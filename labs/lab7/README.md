# Лабораторна робота 7. Лямбда-вираз. Параметризація поведінки

## Цілі лабораторної роботи:
- вивчити процес створення та сценарії використання анонімних об'єктів;
- навчитися створювати анонімні класи;
- розібратися зі створенням одиночних та блокових лямбда-виразів.

## Теоретичний матеріал

### 1. Функціональний інтерфейс `Predicate`

`Predicate` - вбудований функціональний інтерфейс, доданий у Java 8 в пакет `java.util.function`. Інтерфейс описує один метод `test()`, який приймає на вході значення, перевіряє його стан і повертає `boolean` як результат. Інтерфейс `Predicate` підтверджує якесь значення як `true` або `false`.

Інтерфейс виглядає так

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```
> Поки не звертайте увагу на запис `<T>` і `(T t)`, вважайте що там `Object`.

Функціональний дескриптор інтерфейсу
```java
T -> boolean
```

Наступний код

```java
Predicate negative = i -> (int) i < 0;

System.out.println(negative.test(2));
System.out.println(negative.test(-2));
System.out.println(negative.test(0));
```
Виведе у консоль
```
false
true
false
```

Розглянемо реальний приклад, у якому нам може знадобитися функціональний інтерфейс `Predicate`.

Уявімо, що нам треба реалізувати метод для фільтрації масиву цілих чисел. Якщо число задовольняє умові, воно потрапляє у підсумковий масив,
а числа, що не пройшли фільтр, відсіваються. Код такого методу може виглядати так

```java
public int[] filter(int[] input) {
    int[] result = new int[input.length];

    int counter = 0;
    for (int i : input) {
        if ([перевірка_умови]) {
            result[counter] = i;
            counter++;
        }
    }

    return Arrays.copyOfRange(result, 0, counter);
}
```

Особливість даного завдання полягає в тому, що нам вкрай бажано описати лише один метод, який міг би по-різному фільтрувати дані при тому чи іншому виклику.
Ми можемо реалізувати це за допомогою поліморфізму та механізму перевизначення методу, але це буде надто громіздко і не забезпечить належної гнучкості коду.

Нам було б вкрай бажано передати у метод логіку, за якою необхідно фільтрувати вхідний масив. Так як логіка визначається блоком коду, то нам, фактично, треба як один із вхідних аргументів методу фільтрації, передати код для визначення - проходить елемент масиву фільтр чи ні.

#### ⚠️** Механізм функціональних інтерфейсів та лямбда-виразів дозволяє легко передавати поведінку як аргумент методу. За допомогою передачі поведінки ми можемо писати гнучкі методи, робота яких може змінюватися в залежності від переданої в метод поведінки.

Таке завдання можна реалізувати за допомогою функціонального інтерфейсу `Predicate`. Додамо аргумент типу `Predicate` як вхідний аргумент функції і будемо викликати у об'єкта типу `Predicate` метод `test()`, передаючи йому черговий елемент для фільтрації. Якщо метод поверне `true`, то елемент проходить фільтр і потрапляє в результуючий масив.

```java
public int[] filter(int[] input, Predicate p) {
    int[] result = new int[input.length];

    int counter = 0;
    for (int i : input) {
        if (p.test(i)) {
            result[counter] = i;
            counter++;
        }
    }

    return Arrays.copyOfRange(result, 0, counter);
}
```

Тепер ми можемо передавати логіку порівняння за допомогою лямбда-виразу

```java
int[] test = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// Знаходимо парні числа
Predicate pr1 = o -> {
    int value = (int) o;
    return value % 2 == 0;
};

int[] res = filter(test, pr1);
System.out.println(Arrays.toString(res));

// Знаходимо числа, які діляться на 3 без залишку
Predicate pr2 = o -> {
    int value = (int) o;
    return value % 3 == 0;
};

res = filter(test, pr2);
System.out.println(Arrays.toString(res));
```
Програма виведе у консоль наступне
````
[2, 4, 6, 8, 10]
[3, 6, 9]
````

### 2. Функціональний інтерфейс `Consumer`

`Consumer` - вбудований функціональний інтерфейс, доданий Java SE 8 в пакет `java.util.function`. Приймає значення як аргумент і нічого не повертає

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```
Функціональний дескриптор інтерфейсу

```java
T -> void
```

`Consumer` інтерфейс використовується у разі, якщо необхідно передати об'єкт на вхід і зробити над ним деякі операції без повернення результату. Найчастіший випадок використання цього інтерфейсу – це виведення на консоль.

```java

int[] test = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

Consumer consumer = (i) -> System.out.println(i);
forEach(test, consumer);

...

void forEach(int[] input, Consumer action) {
    for (int i : input) {
        action.accept(i);
    }
}
```

### 3. Функціональний інтерфейс `Function`

`Function` - це вбудований функціональний інтерфейс, доданий Java SE 8 в пакет `java.util.function`. Приймає значення як аргумент одного типу і повертає інше значення.

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```
Функціональний дескриптор інтерфейсу

```java
T -> R
```

Цей інтерфейс часто використовується для перетворення одного значення на інше. В інтерфейсі описаний один абстрактний метод `apply()`, який приймає на вхід об'єкт та повертає інший об'єкт (він може бути цього чи будь-якого іншого типу).

```java

int[] test = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

Function function = o -> {
    int value = (int) o;
    return value * 10;
};

int[] result = processArray(test, function);
System.out.println(Arrays.toString(result));

...

int[] processArray(int[] input, Function function) {
    int[] result = new int[input.length];

    for (int i = 0; i < input.length; i++)
        result[i] = (int) function.apply(input[i]);

    return result;
}
```

## Завдання на лабораторну роботу

#### Завдання 1

1. Напишіть предикат, який повертає `true`, якщо число просте. Згенеруйте масив із 1000 випадкових цілих чисел та перевірте роботу фільтра.

#### Завдання 2

1. Даний наступний клас `Student`. У разі потреби додайте необхідні гетери, сетери та конструктори.

```java
class Student {
    private String name;
    private String group;

    private int[] marks;
}
```

2. Напишіть метод фільтрації масиву студентів.
3. Перевірте роботу методу фільтрації на прикладі предикату, який відсіює студентів, які мають 1 та більше заборгованостей (оцінка менше 60).

#### Завдання 3

1. Напишіть метод фільтрації за двома умовами (два предикати). Елемент проходить через фільтр, якщо задовольняє обидві умови.

#### Завдання 4

1. Напишіть `Consumer`, який приймає на вхід об'єкт типу `Student` і виводить у консоль рядок виду `Прізвище + Ім'я`. Створіть масив із кількох студентів та перевірте роботу функції `forEach()`

#### Завдання 5

1. Напишіть метод, який приймає `Predicate` та `Consumer`. Дія в `Consumer` виконується тільки, якщо умова `Predicate` виконується. Створіть масив із цілих чисел, придумайте два лямбда-вирази та перевірте роботу цього методу.

#### Завдання 6

1. Напишіть `Function`, який приймає на вхід ціле число `N` та повертає ціле число `2^N`. Введіть масив із 10 цілих чисел і перевірте роботу методу.

#### Завдання 7

1. Напишіть метод `stringify()`, який приймає на вхід масив цілих чисел від 0 до 9 та `Function`. Напишіть `Function`, який приймає на вхід ціле число від 0 до 9 і повертає його значення у вигляді рядка ("нуль", "один", "два", "три" тощо). Введіть масив із 10 цілих чисел і перевірте роботу методу.

#### Додаткове завдання

Перепишіть виконану програму **SortingList** із 6 лабораторної роботи, щоб вона використовувала механізм лямбда-виразів.
