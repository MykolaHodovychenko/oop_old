# Лабораторная работа 7. Анонимные объекты. Анонимные классы. Лямбда-выражения.

## Цели лабораторной работы:
- изучить процесс создания и сценарии использования анонимных объектов;
- научиться создавать анонимные классы;
- разобраться с созданием одиночных и блочных лямбда-выражения.


## Задание 1. Функциональный интерфейс Predicate

Predicate - встроенный функциональный интерфейс, добавленный в Java 8 в пакет java.util.function. Интерфейс описывает один метод test(), который принимает на входе значение, проверяет его состояние и возвращает boolean в качестве результата. Интерфейс Predicate подтверждает какое-то значение как true или false.

Интерфейс выглядит следующим образом

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```
> Пока не обращайте внимания на запись `<T>` и `(T t)`, считайте что там `Object`.

Функциональный дескриптор интерфейса
```
T -> boolean
```

Следующий код

```java
Predicate negative = i -> (int)i < 0;

System.out.println(negative.test(2));
System.out.println(negative.test(-2));
System.out.println(negative.test(0));
```
Выведет в консоль
```
false
true
false
```

Рассмотрим реальный пример, в котором нам может понадобиться функциональный интерфейс Predicate. 

Представим, что нам надо реализовать метод для фильтрации массива целых чисел. Если число удовлетворяет условию, то оно попадает в итоговый массив,
а числа, не прошедшие фильтр, отсеиваются. Код такого метода может выглядеть следующим образом

```java
public int[] filter(int[] input) {
    int[] result = new int[input.length];

    int counter = 0;
    for (int i : input) {
        if ( [проверка_условия] ) {
            result[counter] = i;
            counter++;
        }
    }

    return Arrays.copyOfRange(result, 0, counter);
}
```

Изюминка данной задачи состоит в том, что нам крайне желательно описать только один метод, который бы мог по-разному фильтровать данные при том или ином вызове.
Мы можем реализовать это с помощью полиморфизма и механизма переопределения метода, но это будет слишком громоздко и не обеспечит должной гибкости кода.

Нам было бы крайне желательно передать в метод логику, по которой необходимо фильтровать входящий массив. Так как логика определяется блоком кода, то нам, фактически, надо в качестве одного из входных аргументов метода фильтрации, передать код для определения - проходит ли элемент массива фильтр или нет.

Такую задачу можно реализовать с помощью функционального интерфейса Predicate. Добавим аргумент типа Predicate в качестве входного аргумента функции и будет вызывать у объекта типа Predicate метод test(), передавая ему очередной элемент для фильтрации. Если метод вернет true, то элемент проходит фильтр и попадает в результирующий массив.

```java
public int[] filter(int[] input, Predicate p) {
    int[] result = new int[input.length];

    int counter = 0;
    for (int i : input) {
        if (p.test(i)) {
            result[counter] = i;
            counter++;
        }
    }

    return Arrays.copyOfRange(result, 0, counter);
}
```

Теперь мы можем передавать логику сравнения с помощью лямбда-выражения

```java
int[] test = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// Находим четные числа
Predicate pr1 = o -> {
    int value = (int) o;
    return value % 2 == 0;
};

int[] res = filter(test, pr1);
System.out.println(Arrays.toString(res));

// Находим числа, которые делятся на 3 без остатка
Predicate pr2 = o -> {
    int value = (int) o;
    return value % 3 == 0;
};

res = filter(test, pr2);
System.out.println(Arrays.toString(res));
```
Программа выведет в консоль следующее
```
[2, 4, 6, 8, 10]
[3, 6, 9]
```
