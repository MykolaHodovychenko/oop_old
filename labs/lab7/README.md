Лабораторна робота 7. Лямбда-вираз. Параметризація поведінки

## Цілі лабораторної роботи:
- вивчити процес створення та сценарії використання анонімних об'єктів;
- навчитися створювати анонімні класи;
- розібратися зі створенням одиночних та блокових лямбда-виразів.

## Теоретичний матеріал

### 1. Функціональний інтерфейс `Predicate`

`Predicate` - вбудований функціональний інтерфейс, доданий у Java 8 в пакет `java.util.function`. Інтерфейс описує один метод `test()`, який приймає на вході значення, перевіряє його стан і повертає `boolean` як результат. Інтерфейс `Predicate` підтверджує якесь значення як `true` або `false`.

Інтерфейс виглядає так

```java
@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);
}
```
> Поки не звертайте увагу на запис `<T>` і `(T t)`, вважайте що там `Object`.

Функціональний дескриптор інтерфейсу
```java
T -> boolean
```

Наступний код

```java
Predicate negative = i -> (int) i < 0;

System.out.println(negative.test(2));
System.out.println(negative.test(-2));
System.out.println(negative.test(0));
```
Виведе у консоль
```
false
true
false
```

Розглянемо реальний приклад, у якому нам може знадобитися функціональний інтерфейс `Predicate`.

Уявімо, що нам треба реалізувати метод для фільтрації масиву цілих чисел. Якщо число задовольняє умові, воно потрапляє у підсумковий масив,
а числа, що не пройшли фільтр, відсіваються. Код такого методу може виглядати так

```java
public int[] filter(int[] input) {
    int[] result = new int[input.length];

    int counter = 0;
    for (int i : input) {
        if ([перевірка_умови]) {
            result[counter] = i;
            counter++;
        }
    }

    return Arrays.copyOfRange(result, 0, counter);
}
```

Особливість даного завдання полягає в тому, що нам вкрай бажано описати лише один метод, який міг би по-різному фільтрувати дані при тому чи іншому виклику.
Ми можемо реалізувати це за допомогою поліморфізму та механізму перевизначення методу, але це буде надто громіздко і не забезпечить належної гнучкості коду.

Нам було б вкрай бажано передати у метод логіку, за якою необхідно фільтрувати вхідний масив. Так як логіка визначається блоком коду, то нам, фактично, треба як один із вхідних аргументів методу фільтрації, передати код для визначення - проходить елемент масиву фільтр чи ні.

#### ⚠️** Механізм функціональних інтерфейсів та лямбда-виразів дозволяє легко передавати поведінку як аргумент методу. За допомогою передачі поведінки ми можемо писати гнучкі методи, робота яких може змінюватися в залежності від переданої в метод поведінки.

Таке завдання можна реалізувати за допомогою функціонального інтерфейсу `Predicate`. Додамо аргумент типу `Predicate` як вхідний аргумент функції і будемо викликати у об'єкта типу `Predicate` метод `test()`, передаючи йому черговий елемент для фільтрації. Якщо метод поверне `true`, то елемент проходить фільтр і потрапляє в результуючий масив.

```java
public int[] filter(int[] input, Predicate p) {
    int[] result = new int[input.length];

    int counter = 0;
    for (int i : input) {
        if (p.test(i)) {
            result[counter] = i;
            counter++;
        }
    }

    return Arrays.copyOfRange(result, 0, counter);
}
```

Тепер ми можемо передавати логіку порівняння за допомогою лямбда-виразу

```java
int[] test = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

// Знаходимо парні числа
Predicate pr1 = o -> {
    int value = (int) o;
    return value % 2 == 0;
};

int[] res = filter(test, pr1);
System.out.println(Arrays.toString(res));

// Знаходимо числа, які діляться на 3 без залишку
Predicate pr2 = o -> {
    int value = (int) o;
    return value % 3 == 0;
};

res = filter(test, pr2);
System.out.println(Arrays.toString(res));
```
Програма виведе у консоль наступне
````
[2, 4, 6, 8, 10]
[3, 6, 9]
````

### 2. Функціональний інтерфейс `Consumer`

`Consumer` - вбудований функціональний інтерфейс, доданий Java SE 8 в пакет `java.util.function`. Приймає значення як аргумент і нічого не повертає

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```
Функціональний дескриптор інтерфейсу

```java
T -> void
```

`Consumer` інтерфейс використовується у разі, якщо необхідно передати об'єкт на вхід і зробити над ним деякі операції без повернення результату. Найчастіший випадок використання цього інтерфейсу – це виведення на консоль.

```java

int[] test = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

Consumer consumer = (i) -> System.out.println(i);
forEach(test, consumer);

...

void forEach(int[] input, Consumer action) {
    for (int i : input) {
        action.accept(i);
    }
}
```

### 3. Функціональний інтерфейс `Function`

`Function` - це вбудований функціональний інтерфейс, доданий Java SE 8 в пакет `java.util.function`. Приймає значення як аргумент одного типу і повертає ін.
